Tutaj notatki z git

====================================================================
git-scm.com/docs
- można kliknąć komendy i dowiedzieć się o nich sporo
- jak czegoś nie wiesz to szukać tutaj
====================================================================

==================================
        Terminal Crash Course:
==================================
    Poruszanie się: 
/s - lista możliwych działań\
ls - list contest of the folder
- pokaże co jest w folderze
ls -a 
- pokaże ukryte pliki (napisane zaczynają się kropką)
start . 
- otworzy lokacje pliku w oknie
ls NazwaFolderu 
- powie co zawiera dany folder
open NazwaFolderu
- otworzy folder
ls NazwaFolderu/NazwaFolderu2
- powie co zawiera folder, który jest w innym folderze
pwd (print working directory)
- powie gdzie teraz jesteśmy (jaka jest nasza lokacja)
cd NazwaFolderu (change directory)
- zmienia logikację, w której jesteśmy na inną (podaną)
clear - czyści ekran komend
cd .. 
- wracamy do poprzedniej lokacji
    Tworzenie, modefikowanie plików i folderów:
touch file.rozrzeszenie w lokacji w jakiej jesteśmy
- tworzy nowy plik np. touch file.txt; można napisać ich kilka bez przecinków 
  pomiędzy i tworzyć wiele na raz; można też tworzyć w lokacjach przez podanie 
  ścieżki np. touch Folder1/Folder2/plik.rozszerzenie
 mkdir NowyFolder (make directory)
 - utworzy nowy folder w lokacji w jakiej jesteś
    Usuwanie folderów i plików:
rm plik.rozszerzenie (remove)
- usuwa plik ale nie do kosza a całkowicie; można kilka po sobie napisać i 
  usunie na raz
rm -rf NazwaFolderu
- usuwa foldery całkowicie a nie do kosza

=================
    Repo
=================
    Basics:
Repository (Repo) - taka jakby ścieżka (folder), którego modyfikacje śledzimy

git status
- daje status repo
git init
- tworzy nowe repo; działanie jedno na cały projekt (wszystkie podfoldery są w repo)
!!! Nie twórz nowego repo w innym repo
!!! sprawdź status i się upewnij

    Committing:
Committing - czyli checkpoint w repo
- można kilka zmienionych plików zaznaczyć jako jeden commit albo podzielić je na kilka 
1. Najpierw trzeba stworzyć pliki i je modyfikować (w statusie pokaże nieśledzone je)
- to jest w working directory
2. Trzeba dać pliki, które chcemy dać do Stage Area 
3. A później zrobić z nich comit
git add NazwaPliku NazwaPliku2 
- stage changes, które później będą comitted; można ile się plików chce (między krokiem 1 a 2)
git commit
- wymaga informacji co się stało (jakaś wiadomość); strzeszczenie co się stało
- uruchomienie git commit sprawi, że wszystkie pliki, które są w stage area będą commited
git commit -m "wiadomość"
- wiadomość odrazu i nie otwiera edytora

!!!!!!!!!
git commit -a -m "wiadomość"
- doda wszystkie zmiany odrazu 
!!!!!!!!!

working tree clean - wszystko jest in sync i up to date

git log
- daje informacje o commitach
git add .
-stage wszystkie zmiany na raz

    Attomic Commits:
Każdy commit powinien odnosić się do jednej rzeczy (jednego problemu)

Można wyszukać słowo (lupa w Visual Studio Code) i zamienić je na inne w każdym z plików gdzie występuje

Zaleca się pisanie wiadomości commitów w czasie Present Simple

    Formating Commits:
Jakby otworzył się VIM to klikając i przenosimy się do instert mode
klikając esc wychodzimy z niego
wpisanie :wq wychodzi z pliku i zapisuje zmiany
Żeby zmienić na Visual Studio Code to: git config --global core.editor "code --wait"
W Visual Studio trzeba wyszukać (CTRL+SHIFT+P) >code i kliknąć Install 'code' command

git log --oneline
short for:: --pretty+oneline --abbrev commit
każda linijka logów będzie krótsza 

git add zapomniany_plik.rozszerzenie
- stage file
git commit __amend
- doda plik do ostatniego commitu / zmienia wiadomość commitu 

touch .gitignore 
- tworzy plik wewnątrz którego można wskazać pliki i foldery, które ma ignorować:
    .Nazwa_Pliku - do plików
    folderName/ - do folderów
    *.log - do logów
- zaznaczanie plików, którymi nigdy nie chcemy się dzielić
Jest baza online nazw plików, które warto dodać https://www.toptal.com/developers/gitignore/

    Git with GUI:
Można otworzyć tam, stage pliki i commitować je.

HEAD -> Master
- head to obecna lokacja (to na co wskazuje strzałka to, na którą gałęź pokazuje)
- co jest obecnie otwarte w repozydorium / gdzie jest obenca gałęź

=================
    Branch
=================
Umożliwiają tworzenie oddzielnych gałęzi (nie wpływają na inne gałęzie projektu; dużo osób może na raz pracować).
- Master branch (główna gałęź repo)
    - Master w Git a Main w Github - to samo
    - Często jest to główna gałęź projektu (ale nie musi być)
- Feature Branches (to inne gałęzie osobne)
!!! hash - unique (to be continued)

To gdzie tworzymy nową branch jest ważne bo będzie ona zawierać wszystko dotychczas
git branch
- pokazuje jakie mamy branches
- by wyjść z listy klikamy q
- tam gdzie jest * jesteśmy obecnie
git branch branch-name
- tworzy nowy branch (ale na nią nie przechodzimy lokalizacyjnie)
git switch branch-name
- zmieniamy branch, której używamy
git switch -c brnach-name
-tworzy i przenosi nas odrazu na branch
git chechkout branch-name
- to samo co switch + odzyskanie working-files
!!! Commit changes zanim zmienisz gałąź !!!
git branch -D branch-name
- usunie branch nieważne czy jest marged czy nie
- trzeba nie być na tej branch a na innej
git  branch -m branch-name
- zmieni nazwę
- trzeba być na tej branch
git branch -v
- pokazuje więcej info o branches

        Wizualizacja przez GUI

        Merging Branches
We merge branches a nie commits
We always merge to the current HEAD branch
    Fast Forward Marge
To używa się jeśli jedna z branches zawiera wszystko co druga i więcej
1. Najpierw idziemy na branch, do którego chcemy dodać inny branch
git switch branch-name
2. git merge branch-name (ale tutaj już nazwa tej branch, którą chcemy dodać)
To tak jakby jest, że ta branch do której dodajemy inny branch przeskakuje chaptery
i już jest gdzie indziej. Robi taki jakby catch-up
    Merge Commit
Ten sam proces ale otworzy inne okno z commitem gdzie można dać nazwę.
    Merge Conflict
1. Kiedy chcemy zrobić jak wyżej ale wyskakuje błąd git powie jakie pliki to problem
2. Otwieramy problemowe pliki
3. Edytujemy pliki by rozwiązać konflikt. Decydujemy co z jakiej branch zostawiamy albo całość.
4. Usuwamy zaznaczenia (markers) z pliku
5. Zapisujemy zmiany a później robimy !commit!

=================
    Git Diff
=================
Pokaże co się zmieniło między commitami, branchami, plikami itd.
git diff
- pokazuje wszystkie zmiany przed stage (tylko unstage pokaże)
- ucieka się przed q
git diff HEAD
- wszystkie zmiany od ostatniego commitu (staged i unstaged)
git diff --staged / git diff --cached
- pokażą tylko staged zmiany (między zmianami a commitem ostatnim)
git diff HEAD nazwa_pliku
- pokaże zmiany do specyficznego pliku
- możliwe, że będzie potrzebne dodanie lokalizacji folder/nazwa_pliku
git diff --staged nazwa_pliku
- pokaże tylko staged zmiany do specyficznego pliku
- możliwe, że będzie potrzebne dodanie lokalizacji folder/nazwa_pliku
git diff branch1..branch2
- porównanie zmian dwóch branch
- kolejność jest ważna bo od tego będzie zależeć co będzie plikiem a i b
git diff commit1..commit2
- co się zmieniło między commitami
-> git log --oneline (by zobaczyć commity)
-> musimy spisać hashe (numery id commitów) commitów, które chcemy porównać
- kolejność się liczy


    Wytłumaczenie kodu, który wyskoczy:
diff --git ...
- pokaże , które pliki porównuje (jeden to plik "a" a drugi plik "b")
--- / +++
- pokaże gdzie jest coś dodane a gdzie usunięte
@@ -3,4 +3,5 @@
- chunks
- pierwsza para numerów jest do pliku a, druga do pliku b
- miusy i plusy pokazują odnoszą się do --- / +++

=================
    Git Stash
=================
index to staging area (Nazewnictwo)
Jeśli zmieniamy branche ale nie zrobimy commita to zmiany mogą pójść z nami albo zrobić stash.
Umożliwa odłożenie zmian na jednej gałęzi i możliwe wrócenie do nich bez niepotrzebnego commita
git stash / git stash save
- wszystkie uncommited zmiany zostaną zapisane w stashu
git stash pop
- doda ostatnio zapisane zmiany, które są w stashu tam gdzie aktualnie jesteś (nawt jeśli to inna branch)
git stash apply
- to tak, że zmiany pojawiają się w pliku a jednocześnie są w stashu przechowywane
- takie duplikowanie trochę ich bo są w dwóch miejscach
Można mieć dużo stashów na raz. Będą one pojawiać się od najstarszego
git stash list
- pokazuje co mamy w stashu
git stash apply stash@{numer_stasha}
- można wybrać dany stash, który chcemy dodać
git stash drop stash@{numer_stasha}
- usuwa podany stash z schowka stashów
git stash clear
- czyści cały schowek stashów

=================
    Other
=================
    git checkout i git switch
- tworzenie nowych branch
- przechodzenie na inne branche
- odzyskiwanie plików
- undo history
git checkout commit_hash 
- hash uzyskujemy dzięki git log --oneline (wystarczy pierwsze 7 cyfr)
- przeniesie nas do stanu detached HEAD 
- idziemy w czasie do poprzedniego commitu (bez późniejszych po nim)
git switch nazwa_branchu
- wracamy do punktu wyjścia
git checkout HEAD~liczba_ile_chcemy_wrócić
- np. git checkout HEAD~1 (wracamy o 1 commit)
git switch -
- przeniesie do ostatniego miejsca, na jakim się znajdowaliśmy
git checkout HEAD nazwa_pliku / git checkout -- nazwa_pliku
- usuwa wszystkie zmiany w pliku i wraca do ostatniego zapisania
git restore nazwa_pliku
- to samo co wyżej; wraca do poprzedniego zapisu
git restore --source HEAD~cyfra nazwa_pliku
- source można wyznaczyć branch (a jak nie to domyślnie tam gdzie jesteś), HEAD~1 albo hash 
git restore --staged nazwa_pliku
- unstage plik
git reset commit_hash
- usuwa commity aż do podanego hasha (ale nie usuwa zmian)
- można stworzyć nowy branch i tam je zapisać
git reset --hard commit_hash
- usunie commity aż do podanego hasha i wszystkie związane z nimi zmiany
git revert commit_hash
- towrzy nowy commit który undos zmiany z innego commitu
- trzeba będzie wpisać wiadomość
- POWINNO się używać tego kiedy pracuje się z innymi na jednym pliku!!!!
- czasami może być konfliky i robimy tak jak w merge

================================================================================================
================================================================================================
    ~~~ GITHUB ~~~~~
=======================
Można dodać tam swoje repo i udostępniać innym i pracować z innymi oraz mieć do niego dostęp z różnych miejsc
Są inne narzędzia niż GitHub takie jak GitLab, BitBucket czy Gerrit
Github to DOM dla Open Source Projects
Konfiguracja SSH Keys (Secure SHell) -> Instrukcje na GitHub
===================
    Cloning
===================
Kopiowanie istniejącego repo
git clone url
- nie można być w istenijącym repo kiedy się to robi (git status)
- utworzy nowy folder z pobranymi plikami
- jeśli plik jest na Githubie to można pobrać repo
- nie trzeba brać url z Githuba można z innych źródeł
=====================================
    Dodawanie Repo do Githuba
=====================================
1 Opcja. Istniejące Repo:
- Utwórz nowe repo na Github
- Połącz ze swoim lokalnym repo
- Push up zmiany do Githuba
2 Opcja. Nowe Repo
- Stwórz nowe repo na Github
- Sklonuj je na swoje urządzenie
    - kopiujemy url z githuba repo i wpisujemy kod git clone url
- Zrób pracę lokalnie
- Push Up zmiany do Githuba

Jak się kliknie na profil to jest dodaj repo

Tylko ta branch, na której jesteśmy podczas klonowania zostanie pobrana.
Reszta branches będzie remote.
Można je zobaczyć po wpisaniu git branch -r
Można je też podejrzeć przez git checkout remote/branch
git switch puppies
- git odrazu połączy z remote branch (po tej samiej nazwie)
    kiedyś: git checkout --track remote/branch
    - ale już się nie korzysta

===============
    Remote
===============
Żeby zrobić Push Up repo trzeba utworzyć destynację do której ma być dodane. Ta destynacja to Remote
git remote -v
- pokaże ci wszystkie repo
git remote add nazwa url
- dodanie nowego remote
- zazwyczaj nazwa to origin
- na stronie Github w nowym repo są linie kodu do skopiowania
git remote rename stara_nazwa nowa_nazwa
- zmienia nazwe
git remote remove nazwa
- usuwa
================
    PUSH UP
================
git push remote branch
- remote (np origin)
- wstawiamy dany branch 
- np. git push origin master (github zmienił master na main więc można zmienić master na main wpisując: git branch -M main)
- jak doda się kilka branches to można między nimi przeskakwiać
git push remote local-branch:remote-branch
- np. git push origin pieski:main
- weźmie branch o nazwie pieski jaką mamy w systemie i doda ją do branch main na github
git push -u remote branch / git push --set-upstream remote branch 
- sets the upstream of the local master branch so that it tracks the master branch on the origianl repo
- wtedy można używać tylko git push i git będzie wiedział domyślnie że lokalna branch i branch na githubie są jednym
- można zrobić kombo łącząc poprzedni kod: git push -u remote branch_local:branch_github

Remote Tracking Branch - reference to the master branch on the remote. Nie da się przenieść.
- jest w miejscu na ostatnim commicie origina master
<remote>/<branch> np. origin/master
git branch -r
- pokaże remote branches
W git status pokaże nam komunikat ile commitów jesteśmy do przodu od remote.

git checkout remote/branch np. git checkout origin/master
- jeśli chcemy zobaczyć jak wyglądalo repozytorium kiedy sklonowaliśmy / ostatnio komunikowaliśmy się z github


=====================
    Git Fetching
=====================
Umożliwia pobranie zmian, które zaszły w remote repo ale nie zostaną one automatycznie zintegrowane z plikami.
Pozwala na zobaczenie nad czym pracowali inni ale bez obowiązku mergowania z własnymi lokalnymi plikami.
Fetchiing to z remote repo do local repo.
git fetch remote
- np. git fetch origin
git fetch remote branch
- pobranie danej gałęzi

====================
    Git Pulling
====================
Pulling to remote repo do workplace.
Sposób na dodanie zmian z remote repo ALE to odrazu aktualizuje HEAD branch poprzez dodanie zmian z remote.
git pull = git fetch + git merge
git pull remote Branch
- ważne skąd / z jakiej lokalizacji będzie wpisana ta komenda. Tam dodane będą zmiany.
Pull może być zakończony merge konfliktem.
Najpierw pull up a później push up (jeśli chcemy dodać do github)
git pull
- z default będzie origin i branch która jest powiązana

============
    Inne
============
Public repo - każdy widzi i ma dostęp ale nie może pushować
Private repo - tylko collaboratorzy i właściciel

!!! Dodawanie COLLABORATORÓW !!!
- mogą pushować zmiany w Repo
1. Wchodzimy w repo na github
2. W ustawienia
3. Manage acces
4. Dodawanie przez username
5. Osoba musi dołączyć i potwierdzić zaproszenie

===============
    README.md
===============

Wyjaśnia co robi projekt, dla kogo, jak instalować i inne info

Plik w rozszerzeniu .md -> Markdown
https://daringfireball.net/projects/markdown/
-> Więcej info o Markdown plikach
https://markdown-it.github.io/
-> Przykładowe jak co robić
-> Wszystko w tych linkach

jak w studiocode >m (wyszukać) to można zobaczyć preview

==============
    Gists
==============

Części kodu, które mają mniej funkcji niż git
Nie trzeba tworzyć nowego repo tylko po prostu dodać na stronę.
Można je udostępniać, mogą mieć różne rozszerzenia itd

Dodawanie: prawy górny róg strony kliknąć plus


https://gist.github.com/discover
-> strona githuba z gists


=================
    gh pages
=================

Github może być hostem stron internetowych ale tylko static sites
Czyli tylko HTML/CSS/JS

https://pages.github.com/

User site 
- jenda na jedno konto Github
- tam można portfolio
- default: username.github.io

Project site:
- nieskończona ilość
- każde Github repo może mieć stronie
- trzeba wskazać która gałąź pokazuje kontent na stronę
- default: username.github.io/repo-name

Jak zrobić:
1. Najpierw stworzyć repozytorium
2. Dodać tam pliki 
3. Zmienić master na main 
4. Jeśli mamy plik html to wtedy idziemy w ustawienia repo
5. W sekcji GitHub Pages zaznaczamy, która branch

================
    Workflow
================

Centralized Workflow - Każdy pracuje na Master branch / jednej branch
- dużo czasu trzeba spędzić by nie było problemów z mergingiem itd.
- problematyczne
- każdy pracuje i zaburza main kod

Feature Branches - Nie pracuj na Master a na innych branches
- master jako oficjalna branch
-> Merging in Feature branches
    Można robić na 3 sposoby:
1. Każdy merguje kiedy chce
2. Wszyscy kolaboratorzy mają dyskusję i uzgadniają co mergować a co nie
3. PULL REQUEST

============
Pull Request -> zawiadamiają osoby pracujące nad repo że są zmiany, które muszą być sprawdzone
============
Oferują mechanizm, który umożliwia akceptowanie lub odrzucanie zmian na branchach.
Na stronie githuba będzie widoczny napis: Comapre & pull Request albo samo pull Request
Jak się je kliknie to można napisać o co się prosi itd.
-> Jeśli jest konflikt to można kliknąć resolve conflicts na github lub kliknąć command line instructions
    Poda nam wtedy dokładne linie kodu do wpisania

=======================
Branch Protection Rules
=======================
Ustawienia -> Branches -> Branch Protection Rules -> Utwórz Rule
Tam można zaznaczyć require pull Request i create

================
    Forking
================

Fork - copy of the original repo

Zamiast jednego repo każdy ma swoje repo + main repo (github workflow)

Jest do tego przycisk (fork) obok repo na github

Działa to tak: fork repo na swoje konto -> pobieramy je na swoje pc -> pracujemy na tym 
                -> push repo na mój fork -> pull request do oryginalnego repo -> pull originalne zmienione
                i od nowa 

=================
    Rebasing
=================

Rebasing to alternatywa mergingu albo używany jako cleanup 

git switch branch_name
git rebase master

To przenosi całą branch na koniec (lastest commit) master branch 

KIEDY NIE UŻYWAĆ rebase
Nigdy nie kiedy commity zostały udostępnione innym.
Kiedy commity są już pushed na github -> chyba że jesteśmy pewni że nikt z colaboratów nie używa tych commitów

Jak działać z konfliktami: w kodzie będą równe rozwiązania i zależnie co będziemy chcieli zrobić to poda nam kod
albo rozwiązać tak jak z mergingiem

=======
cleanup tool
=======
Rewrite history - cleanup tool
git rebase -i HEAD~4
to -i umożliwi nam edytowanie commitów, dodawanie pluków, usuwanie commitów itp.
to co jest po ~ oznacza specyfikacje jak daleko chcemy zmieniać
Nie rebase na master a na HEAD branch

Komendy do clean up:
pick - użycie commitu
reword - zmiana wiadomości commitu
edit - użycie commitu ale zatrzymanie poprawek
fixup - użycie commitu ale złączenie go z poprzednim i usunięcie wiadomości commitu
drop - remove commit
i więcej, które będa zapisane w pliku

=========== 
    Tags
===========
Tagujemy miejsca jako ważne. Często oznacza się wersje: v1.4.4
- lightweight tags - name/label danego commitu
- annotated tags - przetrzymuje extra meta dane w tym dane twórcy i wiadomość

Semanting Versioning czyli co oznacza v2.1.3
Pierwsza cyfra - Major release - zmiany dodane nie działają z poprzednimi wersjami
Druga cyfra - Minor release - nowe features ale nie trzeba nic zmieniać jako użytkownik
Trzecia cyfra - Patch release - często bug vixes itd, ale żadnych zmian features itd.

*w kodzie nie pisać tych <>

git tag - pokaże wszytskie Tagi
git tag -l "*beta*" - pokaże tagi, które zawierają w nazwie beta
git chechout <tag> - da nas do dannego commitu (przeniesie w stan detached HEAD)
git diff <tag> <tag2> - pokaże jakie zmiany między tagami/commitami
git tag <tagname> - tworzenie tagu lightweight
git tag -a <tagname> - tworzenie tagu annotated (otworzy notes tak jak w commitach)
git tag <tagname> <commit_hash> - dodawanie tagu do danego commitu 
git tag -f <tagname> - jak nie da się dodać bo np daliśmy do złego commitu ten tag
git tag -d <tagname> - usuwa tag
git push --tags - doda tagi do githuba bo git push ich automatycznie nie przesyła!!!!

==============
    config
==============
Config file dodaje dodatkowe rzeczy
Znajduje sie w każdym repo

Tutaj więcej info: https://git-scm.com/docs/git-config

git config --local ... - doda lokalnie

============
    Refs
============
Refs folder zawiera plik na każdą branch w repo

============
    HEAD
============
pokazuje gdzie jest HEAD

===============
    Objects
===============
Zawiera wszystkie obiekty repo. Tutaj git ma backupy plików ird.
Pliki są enrypted więc nie powiedzą za dużo

HASHING FUNCTIONS - hashe (przy nazwach commitów)
Hashe mają 40 znaków
SHA-1 algorytm używa git
Git daje nam klucze które umożliwiają dostęp do danych danych i one są w formacie SHA-1

echo 'hello' | git hash-object --stdin - da nam to co w nawiasie ale jako hash
git hash-object <file> - daje nam danych plik ale bez zawartości w hash
git cat-file - pokazuje obiektygit cat-file -p master^{tree} - pokaże tree ostatnie na master

https://git-scm.com/docs/git-hash-object

4 Types of Git Objects:
- Commit - zawiera dane z tree i informacje o tym jak doszło się do danego tree (parents itd), dane twórcy i wiadomości
- tree - objekty, które używa się do przechowywania kontentu danej directory (dane reww zawiera wskaźniki odnoszące się do blobów i innych tree)
- blob (binary large object) - typ obiektu który przechowuje kontent pliku w danym repo. Nie zawiera nazw plików 
- annotated tag

HASHING FUNCTIONS - hashe (przy nazwach commitów)
Hashe mają 40 znaków
SHA-1 algorytm używa git

==============
    Reflog - Cała sekcja 19 (mocno pominięta bo idk o co tu wgl i po co to wgl)
==============
Pokazuje kiedy nastąpiły zmiany w repo dotyczące (head etd)
Są tylko lokalne i 90 dni są tylko w historii

git reflog 
git reflog show HEAD - pokaże nam historie danej branch gdzie jest HEAD
https://git-scm.com/docs/git-reflog - więcej info

name@{qualifier} - uzyskujemy dostęp do specyfinczych refs

Możemy filtrować refs poprzez dodanie czasu w jakim był dany refs
git reflog master@{one.week.ago}
git checkout bugfix@{2.days.ago}
git diff main@{0} main@{yesterday}

git reset --hard master@{1}

================
    Alliases
================
Global Git Config 
~/.gitconfig albo ~/.config/git/config
Wszystkie zmiany zajdą w wszystkich repo

Allias - własna komenda zamiast innej
np. zamiast git status mieć git st
to dodajemy do pliku globalnego configu:
[alias]
    st = status

Przydatne linki:
https://gist.github.com/mwhite/6887990
https://www.udemy.com/course/git-and-github-bootcamp/?couponCode=KEEPLEARNING
https://github.com/GitAlias/gitalias